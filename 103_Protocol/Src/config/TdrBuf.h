/* This file is generated by tdr. */
/* No manual modification is permitted. */

/* creation time: Tue Feb 10 17:59:35 2015 */
/* tdr version: 2.4.21914, build at 20110728 */

#ifndef _TDR_BUF_H_
#define _TDR_BUF_H_

#include <new>
#include <cstdio>
#include <cassert>
#include <cstring>
#include <cstdarg>

#include "TdrPal.h"
#include "TdrError.h"

namespace tsf4g_tdr
{


class TdrWriteBuf
{
    private:
        char* beginPtr;
        size_t position;
        size_t length;

    private:
        bool needFree;

    private:
        void _free()
        {
            delete [] beginPtr;
            needFree = false;
            beginPtr = NULL;
        }

        void _set(char* ptr, size_t size)
        {
            beginPtr = ptr;
            position = 0;
            if (NULL == beginPtr)
            {
                length = 0;
            } else
            {
                length = size;
            }
        }
        void _reset()
        {
            beginPtr = NULL;
            length = 0;
            position = 0;
        }

    public:
        TdrWriteBuf()
        {
            needFree = false;
            _reset();
        }

        TdrWriteBuf(size_t size)
        {
            char* ptr = new(std::nothrow) char [size];
            if (NULL != ptr)
            {
                needFree = true;
            } else
            {
                needFree = false;
            }
            _set(ptr, size);
        }

        TdrWriteBuf(char* ptr, size_t size)
        {
            needFree = false;
            _set(ptr, size);
        }

        ~TdrWriteBuf()
        {
            if (needFree)
            {
                _free();
            }
        }

        void reset()
        {
            if (needFree)
            {
                _free();
            }
            _reset();
        }

        void set(char* ptr, size_t size)
        {
            if (needFree)
            {
                _free();
            }
            _set(ptr, size);
        }

        size_t getUsedSize() const
        {
            return position;
        }

        size_t getTotalSize() const
        {
            return length;
        }

        size_t getLeftSize() const
        {
            assert(position <= length);

            return length - position;
        }

        const char* getBeginPtr() const
        {
            return beginPtr;
        }

        TdrError::ErrorType reserve(size_t gap)
        {
            assert(position <= length);

            if (position > length)
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            if (gap > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            position += gap;

            return TdrError::TDR_NO_ERROR;
        }

    public: /* print data visually */
        TdrError::ErrorType vtextize(const char* format, va_list ap)
        {
            int ret = tdr_cpp_vsnprintf(beginPtr + position, length - position, format, ap);
            if (0 > ret || (size_t)ret >= (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }
            position += ret;

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType textize(const char* format, ...)
        {
            va_list ap;

            va_start(ap, format);
            int ret = tdr_cpp_vsnprintf(beginPtr + position, length - position, format, ap);
            va_end(ap);
            if (0 > ret || (size_t)ret >= (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }
            position += ret;

            return TdrError::TDR_NO_ERROR;
        }

    public: /* write successively */
        TdrError::ErrorType writeChar(const char src)
        {
            return writeUInt8(*(uint8_t*)&src);
        }

        /* this function is supposed to be called by visualize() directly or indiectly */
        TdrError::ErrorType writeCharWithNull(const char src)
        {
            assert(position <= length);

            if (sizeof(src) + 1 > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            *(char*)(beginPtr + position) = src;
            position += sizeof(src);

            /* a null character is writed, but keeps position untouched */
            *(char*)(beginPtr + position) = '\0';

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType writeUChar(const unsigned char src)
        {
            return writeUInt8(*(uint8_t*)&src);
        }

        TdrError::ErrorType writeInt8(const int8_t src)
        {
            return writeUInt8(*(uint8_t*)&src);
        }

        TdrError::ErrorType writeUInt8(const uint8_t src)
        {
            assert(position <= length);

            if (sizeof(src) > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            *(uint8_t*)(beginPtr + position) = src;
            position += sizeof(src);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType writeInt16(const int16_t src)
        {
            return writeUInt16(*(uint16_t*)&src);
        }

        TdrError::ErrorType writeUInt16(const uint16_t src)
        {
            assert(position <= length);

            if (sizeof(src) > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            *(uint16_t*)(beginPtr + position) = tdr_cpp_hton16(src);
            position += sizeof(src);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType writeInt32(const int32_t src)
        {
            return writeUInt32(*(uint32_t*)&src);
        }

        TdrError::ErrorType writeUInt32(const uint32_t src)
        {
            assert(position <= length);

            if (sizeof(src) > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            *(uint32_t*)(beginPtr + position) = tdr_cpp_hton32(src);
            position += sizeof(src);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType writeInt64(const int64_t src)
        {
            return writeUInt64(*(uint64_t*)&src);
        }

        TdrError::ErrorType writeUInt64(const uint64_t src)
        {
            assert(position <= length);

            if (sizeof(src) > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            *(uint64_t*)(beginPtr + position) = tdr_cpp_hton64(src);
            position += sizeof(src);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType writeFloat(const float src)
        {
            return writeUInt32(*(uint32_t*)&src);
        }

        TdrError::ErrorType writeDouble(const double src)
        {
            return writeUInt64(*(uint64_t*)&src);
        }

        TdrError::ErrorType writeBytes(const void* src, size_t count)
        {
            if (NULL == src)
            {
                return TdrError::TDR_ERR_ARG_POINTER_IS_NULL;
            }

            assert(position <= length);

            if (count > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            memmove(beginPtr + position, src, count);
            position += count;

            return TdrError::TDR_NO_ERROR;
        }

    public: /* write directly */
        TdrError::ErrorType writeChar(const char src, size_t pos)
        {
            return writeUInt8((uint8_t)src, pos);
        }

        TdrError::ErrorType writeUChar(const unsigned char src, size_t pos)
        {
            return writeUInt8((uint8_t)src, pos);
        }

        TdrError::ErrorType writeInt8(const int8_t src, size_t pos)
        {
            return writeUInt8((uint8_t)src, pos);
        }

        TdrError::ErrorType writeUInt8(const uint8_t src, size_t pos)
        {
            assert(position <= length);

            if (pos > length)
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            if (sizeof(src) > (length - pos))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            *(uint8_t*)(beginPtr + pos) = src;

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType writeInt16(const int16_t src, size_t pos)
        {
            return writeUInt16((uint16_t)src, pos);
        }

        TdrError::ErrorType writeUInt16(const uint16_t src, size_t pos)
        {
            assert(position <= length);

            if (pos > length)
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            if (sizeof(src) > (length - pos))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            *(uint16_t*)(beginPtr + pos) = tdr_cpp_hton16(src);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType writeInt32(const int32_t src, size_t pos)
        {
            return writeUInt32((uint32_t)src, pos);
        }

        TdrError::ErrorType writeUInt32(const uint32_t src, size_t pos)
        {
            assert(position <= length);

            if (pos > length)
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            if (sizeof(src) > (length - pos))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            *(uint32_t*)(beginPtr + pos) = tdr_cpp_hton32(src);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType writeInt64(const int64_t src, size_t pos)
        {
            return writeUInt64((uint64_t)src, pos);
        }

        TdrError::ErrorType writeUInt64(const uint64_t src, size_t pos)
        {
            assert(position <= length);

            if (pos > length)
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            if (sizeof(src) > (length - pos))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            *(uint64_t*)(beginPtr + pos) = tdr_cpp_hton64(src);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType writeFloat(const float src, size_t pos)
        {
            return writeUInt32(*(uint32_t*)&src, pos);
        }

        TdrError::ErrorType writeDouble(const double src, size_t pos)
        {
            return writeUInt64(*(uint64_t*)&src, pos);
        }

        TdrError::ErrorType writeBytes(const void* src, size_t count, size_t pos)
        {
            if (NULL == src)
            {
                return TdrError::TDR_ERR_ARG_POINTER_IS_NULL;
            }

            assert(position <= length);

            if (count > (length - pos))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_WRITE;
            }

            memmove(beginPtr + pos, src, count);

            return TdrError::TDR_NO_ERROR;
        }
};

class TdrReadBuf
{
    private:
        const char* beginPtr;
        size_t position;
        size_t length;

    public:
        TdrReadBuf()
        {
            reset();
        }

        TdrReadBuf(const char* ptr, size_t size)
        {
            set(ptr, size);
        }

        explicit TdrReadBuf(const TdrWriteBuf& writeBuf)
        {
            set(writeBuf.getBeginPtr(), writeBuf.getUsedSize());
        }

        void reset()
        {
            beginPtr = NULL;
            length = 0;
            position = 0;
        }

        void set(const char* ptr, size_t size)
        {
            beginPtr = ptr;
            position = 0;
            if (NULL == beginPtr)
            {
                length = 0;
            } else
            {
                length = size;
            }
        }

        size_t getUsedSize() const
        {
            return position;
        }

        size_t getTotalSize() const
        {
            return length;
        }

        size_t getLeftSize() const
        {
            assert(position <= length);

            return length - position;
        }

        const char* getCurrentPtr() const
        {
            return beginPtr + position;
        }

        TdrError::ErrorType toHexStr(char* destBuf, size_t len, size_t* usedLen = NULL) const;

        TdrError::ErrorType fromHexStr(const char* srcHexStr, size_t len, size_t* usedLen = NULL);

    public: /* read successively */
        TdrError::ErrorType readChar(char& dest)
        {
            return readUInt8(*(uint8_t*)&dest);
        }

        TdrError::ErrorType readUChar(unsigned char& dest)
        {
            return readUInt8(*(uint8_t*)&dest);
        }

        TdrError::ErrorType readInt8(int8_t& dest)
        {
            return readUInt8(*(uint8_t*)&dest);
        }

        TdrError::ErrorType readUInt8(uint8_t& dest)
        {
            assert(position <= length);

            if (sizeof(dest) > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            dest = *(uint8_t*)(beginPtr + position);
            position += sizeof(dest);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType readInt16(int16_t& dest)
        {
            return readUInt16(*(uint16_t*)&dest);
        }

        TdrError::ErrorType readUInt16(uint16_t& dest)
        {
            assert(position <= length);

            if (sizeof(dest) > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            dest = tdr_cpp_ntoh16(*(uint16_t*)(beginPtr + position));
            position += sizeof(dest);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType readInt32(int32_t& dest)
        {
            return readUInt32(*(uint32_t*)&dest);
        }

        TdrError::ErrorType readUInt32(uint32_t& dest)
        {
            assert(position <= length);

            if (sizeof(dest) > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            dest = tdr_cpp_ntoh32(*(uint32_t*)(beginPtr + position));
            position += sizeof(dest);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType readInt64(int64_t& dest)
        {
            return readUInt64(*(uint64_t*)&dest);
        }

        TdrError::ErrorType readUInt64(uint64_t& dest)
        {
            assert(position <= length);

            if (sizeof(dest) > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            dest = tdr_cpp_ntoh64(*(uint64_t*)(beginPtr + position));
            position += sizeof(dest);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType readFloat(float& dest)
        {
            return readUInt32(*(uint32_t*)&dest);
        }

        TdrError::ErrorType readDouble(double& dest)
        {
            return readUInt64(*(uint64_t*)&dest);
        }

        TdrError::ErrorType readBytes(void* dest, size_t count)
        {
            if (NULL == dest)
            {
                return TdrError::TDR_ERR_ARG_POINTER_IS_NULL;
            }

            assert(position <= length);

            if (count > (length - position))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            memmove(dest, beginPtr + position, count);
            position += count;

            return TdrError::TDR_NO_ERROR;
        }

    public: /* read directly */
        TdrError::ErrorType readChar(char& dest, size_t pos)
        {
            return readUInt8(*(uint8_t*)&dest, pos);
        }

        TdrError::ErrorType readUChar(unsigned char& dest, size_t pos)
        {
            return readUInt8(*(uint8_t*)&dest, pos);
        }

        TdrError::ErrorType readInt8(int8_t& dest, size_t pos)
        {
            return readUInt8(*(uint8_t*)&dest, pos);
        }

        TdrError::ErrorType readUInt8(uint8_t& dest, size_t pos)
        {
            assert(position <= length);

            if (pos > length)
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            if (sizeof(dest) > (length - pos))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            dest = *(uint8_t*)(beginPtr + pos);

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType readInt16(int16_t& dest, size_t pos)
        {
            return readUInt16(*(uint16_t*)&dest, pos);
        }

        TdrError::ErrorType readUInt16(uint16_t& dest, size_t pos)
        {
            assert(position <= length);

            if (pos > length)
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            if (sizeof(dest) > (length - pos))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            dest = tdr_cpp_ntoh16(*(uint16_t*)(beginPtr + pos));

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType readInt32(int32_t& dest, size_t pos)
        {
            return readUInt32(*(uint32_t*)&dest, pos);
        }

        TdrError::ErrorType readUInt32(uint32_t& dest, size_t pos)
        {
            assert(position <= length);

            if (pos > length)
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            if (sizeof(dest) > (length - pos))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            dest = tdr_cpp_ntoh32(*(uint32_t*)(beginPtr + pos));

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType readInt64(int64_t& dest, size_t pos)
        {
            return readUInt64(*(uint64_t*)&dest, pos);
        }

        TdrError::ErrorType readUInt64(uint64_t& dest, size_t pos)
        {
            assert(position <= length);

            if (pos > length)
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            if (sizeof(dest) > (length - pos))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            dest = tdr_cpp_ntoh64(*(uint64_t*)(beginPtr + pos));

            return TdrError::TDR_NO_ERROR;
        }

        TdrError::ErrorType readFloat(float& dest, size_t pos)
        {
            return readUInt32(*(uint32_t*)&dest, pos);
        }

        TdrError::ErrorType readDouble(double& dest, size_t pos)
        {
            return readUInt64(*(uint64_t*)&dest, pos);
        }

        TdrError::ErrorType readBytes(void* dest, size_t count, size_t pos)
        {
            if (NULL == dest)
            {
                return TdrError::TDR_ERR_ARG_POINTER_IS_NULL;
            }

            assert(position <= length);

            if (count > (length - pos))
            {
                return TdrError::TDR_ERR_SHORT_BUF_FOR_READ;
            }

            memmove(dest, beginPtr + pos, count);

            return TdrError::TDR_NO_ERROR;
        }
};

template<typename TYPE>
TdrError::ErrorType
restoreFromHexStr(TYPE& data, const char* srcHexStr, size_t len, size_t* usedLen = NULL)
{
    if (NULL == srcHexStr)
    {
        return TdrError::TDR_ERR_NULL_POINTER_PARAMETER;
    }

    return TdrReadBuf((char*)&data, sizeof(data)).fromHexStr(srcHexStr, len, usedLen);
}

}
#endif
